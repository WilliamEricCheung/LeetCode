package tech.wec.Math;

public class NumberOfDigitOne_233 {
    class Solution {
        /*
         * 按十进制分为高、当前、低位，则规律为：
         * 若当前位小于1，则高位的数值减一，低位数字全变成9；（如82103，当前位是十位的时候，则高位减一得820，低位变成9）；
         * 若当前位等于1，则高位和低位都保持不变；（如82103，当前位是百位的时候，则高位保持为82，低位保持为03）；
         * 若当前位大于1，则高位保持不变，低位数字全变成9；（如82103，当前位是万位的时候，高位为0保持不变，低位变成9999）。
         * 然后，去掉当前位，合并高位和低位得到一个中间数字t（如82103，当前位是百位的时候，则去掉百位，合并高低位之后得到8203），
         * 那么锁定当前位为1，则其他位的变化为 [0, t]，共有t+1种变化（0000~8203共8204种变化）。
         * 按上面的方法遍历输入数的每一个十进制位，可以得到一共有多少种变化。
         * 上面的例子输入82103，则有 (8210+1) + (8209+1) + (8203+1) + (8999+1) + (9999+1) = 43625 种变化。
         */

        public int countDigitOne(int n){
            int high = n, count = 0, scale = 1, curr;
            while (true) {
                curr = high % 10;
                high /= 10;
                count += high * scale;          // t的高位
                if (curr == 1)
                    count += n % scale + 1;     // t的低位+1
                else if (curr > 1)
                    count += scale;             // t的低位全变成9再加1，其实这里是 (scale-1)+1

                // 后面还有一个else没写，因为当前位小于1时
                // t的高位是 high-1，低位是 scale-1（即全变成9）
                // ((high-1)*scale+(scale-1))+1 就等于 high*scale
                if (high == 0)
                    break;
                scale *= 10;                    // 这一条语句必须放在break后面，否则可能发生int类型溢出
            }
            return count;
        }
    }
}
